<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DAG 状态图（含独立节点）</title>
  <style>
    body {
      font-family: sans-serif;
    }

    .node {
      padding: 10px;
      border-radius: 6px;
      color: white;
      width: 100px;
      text-align: center;
      position: absolute;
      transition: background-color 0.3s;
    }

    .edge {
      stroke: black;
      stroke-width: 2;
      marker-end: url(#arrow);
    }

    .Waiting { background-color: gray; }
    .Running { background-color: steelblue; }
    .Success { background-color: green; }
    .Failed  { background-color: red; }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      z-index: -1;
    }
  </style>
</head>
<body>
  <h2>DAG 节点依赖图（含独立节点）</h2>

  <div id="graph"></div>
  <svg width="1200" height="600">
    <defs>
      <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
        <path d="M0,0 L0,6 L9,3 z" fill="#000" />
      </marker>
    </defs>
  </svg>

  <script>
    const Status = { Waiting: 0, Running: 1, Success: 2, Failed: 3 };

    class Node {
      constructor(id) {
        this.id = id;
        this.dependencies = new Set();
        this.dependents = new Set();
      }
    }

    class DAG {
      constructor() {
        this.nodes = new Map();
      }

      addNode(node, override = false) {
        if (!this.has(node.id) || override) this.nodes.set(node.id, node);
      }

      getNode(id) {
        return this.nodes.get(id);
      }

      has(id) {
        return this.nodes.has(id);
      }

      addDependency(sourceId, targetId) {
        const source = this.getNode(sourceId);
        const target = this.getNode(targetId);
        if (!source || !target) return false;
        if (this.hasPath(targetId, sourceId)) return false;
        source.dependencies.add(targetId);
        target.dependents.add(sourceId);
        return true;
      }

      hasPath(from, to) {
        const visited = new Set();
        const stack = [from];
        while (stack.length) {
          const id = stack.pop();
          if (id === to) return true;
          if (visited.has(id)) continue;
          visited.add(id);
          const node = this.getNode(id);
          if (node) stack.push(...node.dependencies);
        }
        return false;
      }
    }

    class StatefulNode extends Node {
      constructor(id) {
        super(id);
        this.status = Status.Waiting;
        this.data = undefined;
      }

      async onLoad(data) {
        if (['B', 'C', 'E', 'G', 'H', 'I'].includes(this.id)) {
          await new Promise(res => setTimeout(res, 2000));
        }
        this.data = `${this.id}_result`;
      }

      onSuccess() { }
      onFailed() { }
      onFinished() { }
    }

    class StatefulDAG extends DAG {
      async run(id) {
        const node = this.tryActivate(id);
        if (!node) return;

        try {
          const depsData = this.getDependencyData(id);
          await Promise.resolve(node.onLoad(depsData));
          node.status = Status.Success;
          node.onSuccess();
        } catch {
          node.status = Status.Failed;
          node.onFailed();
        } finally {
          node.onFinished();
          updateNodeView(node);
        }

        for (const dependentId of node.dependents) {
          this.run(dependentId);
        }
      }

      tryActivate(id) {
        const node = this.getNode(id);
        if (!node || node.status !== Status.Waiting) return false;
        for (const depId of node.dependencies) {
          const dep = this.getNode(depId);
          if (!dep || dep.status !== Status.Success) return false;
        }
        node.status = Status.Running;
        updateNodeView(node);
        return node;
      }

      getDependencyData(id) {
        const node = this.getNode(id);
        const result = {};
        if (!node) return result;
        for (const depId of node.dependencies) {
          const dep = this.getNode(depId);
          if (dep && dep.status === Status.Success) {
            result[depId] = dep.data;
          }
        }
        return result;
      }
    }

    const layout = {
      A: { x: 400, y: 50 },
      B: { x: 250, y: 150 },
      C: { x: 550, y: 150 },
      D: { x: 150, y: 250 },
      E: { x: 350, y: 250 },
      F: { x: 650, y: 250 },
      G: { x: 500, y: 350 },
      H: { x: 800, y: 100 }, // 独立
      I: { x: 850, y: 300 }, // 独立
    };

    const graphDiv = document.getElementById("graph");
    const svg = document.querySelector("svg");

    function renderNode(node) {
      const div = document.createElement("div");
      div.className = `node Waiting`;
      div.id = `node-${node.id}`;
      div.textContent = node.id;
      const { x, y } = layout[node.id];
      div.style.left = x + "px";
      div.style.top = y + "px";
      graphDiv.appendChild(div);
    }

    function updateNodeView(node) {
      const el = document.getElementById(`node-${node.id}`);
      if (el) {
        el.className = `node ${Object.keys(Status)[node.status]}`;
      }
    }

    function drawEdge(from, to) {
      const f = layout[from];
      const t = layout[to];
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", f.x + 50);
      line.setAttribute("y1", f.y + 20);
      line.setAttribute("x2", t.x + 50);
      line.setAttribute("y2", t.y + 20);
      line.classList.add("edge");
      svg.appendChild(line);
    }

    const dag = new StatefulDAG();
    const ids = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
    ids.forEach(id => {
      const node = new StatefulNode(id);
      dag.addNode(node);
      renderNode(node);
    });

    // 设置依赖关系
    dag.addDependency('B', 'A');
    dag.addDependency('C', 'A');
    dag.addDependency('D', 'B');
    dag.addDependency('E', 'B');
    dag.addDependency('F', 'C');
    dag.addDependency('G', 'E');
    dag.addDependency('G', 'F');

    // 绘制连接线
    drawEdge('A', 'B');
    drawEdge('A', 'C');
    drawEdge('B', 'D');
    drawEdge('B', 'E');
    drawEdge('C', 'F');
    drawEdge('E', 'G');
    drawEdge('F', 'G');

    // 启动所有节点（包括独立）
    dag.run('A');
    dag.run('H');
    dag.run('I');
  </script>
</body>
</html>
